L378. What is mongoose

    ODM - Object Data Mapper - Object document Mapper
    it connects node.js and mongodb

L379. Connecting Mongoose to Mongo
    npm init -y : in a new folder to initalize package.json
    npm i mongoose
    touch index.js
    // open mongodb and leave it open in the background

    // contents of index.js
    const mongoose = require('mongoose'); // require mongoose after installing it on npm
    mongoose.connect('mongodb://localhost:27017/movieApp', {useNewUrlParser: true, useUnifiedTopology: true}) 
        .then(() => { // try
            console.log("CONNECTION OPEN!!!")
        })
        .catch(err => { // catch if error
            console.log("OH NO ERROR !!!");
            console.log(err);
        })
        
    // in the console in this folder run:
    node index.js

L380. Our First Mongoose Model
    > node
    > .load index.js
    const mongoose = require('mongoose'); // require mongoose after installing 
    it on npm
    mongoose.connect('mongodb://localhost:27017/movieApp', {useNewUrlParser: true, useUnifiedTopology: true}) // where to find mongodb locally / database 
    (if it dosent exist one will be created)
    .then(() => { // try
        console.log("CONNECTION OPEN!!!")
        })
        .catch(err => { // catch if error
            console.log("OH NO ERROR !!!");
                console.log(err);
                })

                // Our first mongoose model

                // schemas
                const movieSchema = new mongoose.Schema({
                    title: String,
                        year: Number,
                            score: Number,
                                rating: String
                                })

                                // take the schema and tell mongoose to make a 
    model using the schema
                                const Movie = mongoose.model('Movie', movieSchema) // pass in name of model and the schema, Movie createw a collection 'movies' in mongoose , save it to a variable and save it to a variable Movie  
                                const amadeus = new Movie ({title: 'Amadeus', year: 1986, score: 9.2, rating: 'R'})
    Promise { <pending> }
    > CONNECTION OPEN!!!

    >
    >
    >
    >
    >
    >
    > amadeus
    {
    _id: 60760396fd4201420c7abf85,
    title: 'Amadeus',
    year: 1986,
    score: 9.2,
    rating: 'R'
    }
    
    // up until this point nothing has been saved to the db

    // Saving to mongo database
    > amadeus.save()
    Promise { <pending> }

    // in our mongodb shell :
    > db.movies.find()
    { "_id" : ObjectId("60760396fd4201420c7abf85"), "title" : "Amadeus", "year" : 1986, "score" : 9.2, "rating" : "R", "__v" : 0 }

    // back to the node powershell:
        > amadeus.score = 9.5
        9.5 // changing it in the js only
        > amadeus.save() // saving the change to database
        Promise { <pending> }
    // checking mongodb shell:
        > db.movies.find() // checking to see that we saved changes on the database side
{ "_id" : ObjectId("60760396fd4201420c7abf85"), "title" : "Amadeus", "year" : 1986, "score" : 9.5, "rating" : "R", "__v" : 0 }

L381. Insert Many
    // after writing the javascript in the indes file run:
    node index.js : confirm that Insert Many is working

    // to check the database make sure im in the moviesApp database and view the contents
    open mongodb powershell
    > use movieApp
    switched to db movieApp
    > db.movies.find()  
        // Result: the objects in the insertMany array in index.js

L382. Finding With Mongoose
    we will connect to mongo , we will keep the movie model , but we are going to comment out the next
    navigate to project folder
    node : node REPL
    .load index.js : running the js file ending with a CONNECTION OPEN!!!  message

    // just running Movie.find() will result in more info than what we need, so we use the then method to log only the data
    Movie.find({}).then(data => console.log(data)) // this filters out relivant data like with promises
    Promise { <pending> }
    > [
    {
        _id: 60760396fd4201420c7abf85,
        title: 'Amadeus',
        year: 1986,
        score: 9.5,
        rating: 'R',
        __v: 0
    },
    {
        _id: 60761452822fc55b7cdd11af,
        title: 'Amelie',
        year: 2001,
        score: 8.3,
        rating: 'R',
        __v: 0
    },
    {
        _id: 60761452822fc55b7cdd11b0,
        title: 'Alien',
        year: 1979,
        score: 8.1,
        rating: 'R',
        __v: 0
    },
    {
        _id: 60761452822fc55b7cdd11b1,
        title: 'The Iron Giant',
        year: 1999,
        score: 7.5,
        rating: 'PG',
        __v: 0
    },
    {
        _id: 60761452822fc55b7cdd11b2,
        title: 'Stand By Me',
        year: 1986,
        score: 8.6,
        rating: 'R',
        __v: 0
    },
    {
        _id: 60761452822fc55b7cdd11b3,
        title: 'Moonrise Kingdom',
        year: 2012,
        score: 7.3,
        rating: 'PG-13',
        __v: 0
    }
    ]

    // Find movie that is PG-13
    > Movie.find({rating: 'PG-13'}).then(data => console.log(data))
    Promise { <pending> }
    > [
    {
        _id: 60761452822fc55b7cdd11b3,
        title: 'Moonrise Kingdom',
        year: 2012,
        score: 7.3,
        rating: 'PG-13',
        __v: 0
    }
    ]

    // find movie more recent than 2010
    > Movie.find({year: {$gte: 2010}}).then(data => console.log(data))
    Promise { <pending> }
    > [
    {
        _id: 60761452822fc55b7cdd11b3,
        title: 'Moonrise Kingdom',
        year: 2012,
        score: 7.3,
        rating: 'PG-13',
        __v: 0
    }
    ]

    >Movie.find({rating: 'PG-13'}).then(data => console.log(data))
            // returns just the ones with the PG-13 ratings

    we can also querry like this
        > Movie.find({year: {$gte: 2010}}).then(data => console.log(data))
            // returns movies newer than or equal to year 2010
        > Movie.find({year: {$lt: 1990}}).then(data => console.log(data))
            // returns 1990 and older
        > Movie.findOne({}).then(m => console.log(m))
            // finds one instance (first one)
        > Movie.find({_id: '60760396fd4201420c7abf85'}).then(m => console.log(m))
            // returns item in Movie db with matching id

L383. Updating in mongoose
    in mongo shell check to see what year amadeus is set to
        > db.movies.find({title: 'Amadeus'})
        { "_id" : ObjectId("60760396fd4201420c7abf85"), "title" : "Amadeus", "year" : 1986, "score" : 9.5, "rating" : "R", "__v" : 0 }

    updating the date to 1984 in terminal using updateOne
        > Movie.updateOne({title: 'Amadeus'}, {year: 1984}).then(res => console.log(res))
        > { n: 1, nModified: 1, ok: 1 }

    check in the mongo shell to see that it was actually changed
        > db.movies.find({title: 'Amadeus'})

    using updateManu in node terminal
        > Movie.updateMany({title: {$in: ['Amadeus', 'Stand By Me']}}, {score: 10}).then(res => console.log(res))
            //returns:
            Promise { <pending> }
            > { n: 4, nModified: 4, ok: 1 }

    In the mongo shell to see if the changes have been made to the scores
            > db.movies.find({title: {$in: ['Amadeus', 'Stand By Me']}})
                { "_id" : ObjectId("60760396fd4201420c7abf85"), "title" : "Amadeus", "year" : 1984, "score" : 10, "rating" : "R", "__v" : 0 }
                { "_id" : ObjectId("60761452822fc55b7cdd11b2"), "title" : "Stand By Me", "year" : 1986, "score" : 10, "rating" : "R", "__v" : 0 }
                { "_id" : ObjectId("60ac44b2be9a0444c80216c0"), "title" : "Stand By Me", "year" : 1986, "score" : 10, "rating" : "R", "__v" : 0 }
                { "_id" : ObjectId("60ac4823e68f405dac0ed38b"), "title" : "Stand By Me", "year" : 1986, "score" : 10, "rating" : "R", "__v" : 0 }

    > Movie.findOneAndUpdate({title: 'The Iron Giant'}, {score: 7.0}).then(m => console.log(m))
        // returns: // supposidly it returns the old version
            Promise { <pending> }
                > {
                _id: 60761452822fc55b7cdd11b1,
                title: 'The Iron Giant',
                year: 1999,
                score: 7,
                rating: 'PG',
                __v: 0
                }

     do the same but return the modified function with a diffrent score this time
        > Movie.findOneAndUpdate({title: 'The Iron Giant'}, {score: 7.8}, {new: true}).then(m => console.log(m))
        // returns modified version :
            {
            _id: 60761452822fc55b7cdd11b1,
            title: 'The Iron Giant',
            year: 1999,
            score: 7.8,
            rating: 'PG',
            __v: 0
            }

384. Deleting With Mongoose

        help in the mongo shell can show me some commands

    //delete every instance
        >Movie.remove({title: 'Amelie'}).then(msg => console.log(msg))
            // returns:
                Promise { <pending> }
                > (node:12276) DeprecationWarning: collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.
                { n: 4, ok: 1, deletedCount: 4 }

        > Movie.deleteMany({year: {$gte: 1999}}).then(msg => console.log(msg))
            returns:
                Promise { <pending> }
                > { n: 6, ok: 1, deletedCount: 6 }
            check in mongo shell if it works:
                in mongo shell : use movieApp
                db.movies.find()

    // here I return the result after deleting a single selection
        > Movie.findOneAndDelete({title:'Alien'}).then(m => console.log(m))

385. Mongoose Schema validations
    in sec37 dir touch product.js
    copy over connection logic from index.js
    change line 2 from movie app to shopApp
    open  mongodb and leave it open
    in product.js containing dir run: node
                                then: .load product.js
    mongoShell> show dbs : to verify shopApp db is created
    use shopApp : to switch to the db
    db.products.find()

    * start up shopApp database

386. Additional Schema Constraints

    adding to schema in product.js:
        onSale: {
        type: Boolean,
        default: false
    }
    // next change the line that makes a new product:
        const Product = mongoose.model('Product',productSchema);

    // see in mongo shell if new object was created
        > db.products.find()
         // we can see that nothing was added because it did not pass the string length validator

    // we can add constraint to numbers schema: min: 0
    // then change the new bike price to a - to see what happens: it runs an error and dosent save because of the number validator we set
    
    // in the schema we add : categories : [String]
    then we change the new bike product
         const bike = new Product({ name: 'Bike Helmet', price:19.50, categories: ['Cycling', 'Safety'] })
    restart product.js in node and check in db to see that the new bike obj has been saved

    // if i do it again and add a number to categories like so :
        const bike = new Product({ name: 'Bike Helmet', price:19.50, categories: ['Cycling', 'Safety', 1234] })
            // it works but it changes the number to a string due to the validation we set:
                {
                onSale: false,
                categories: [ 'Cycling', 'Safety', '1234' ],
                _id: 60ad338d19725952c45a6ace,
                name: 'Bike Helmet',
                price: 19.5,
                __v: 0
                }

    // for categories schema:
         categories: [String],
                qty: {
                    online: {
                        type: Number,
                        default: 0
                    },
                    instore: {
                        type: Number,
                        default: 0
                    }
                }

    // re run project.js 
        result: we can see the default qty's
            {
            qty: { online: 0, instore: 0 },
            onSale: false,
            categories: [ 'Cycling', 'Safety', '1234' ],
            _id: 60ad35ccf0ea9031e857a1ba,
            name: 'Bike Helmet',
            price: 19.5,
            __v: 0
            }

387. Vaildating Mongoose updates

        const bike = new Product({ name: 'Tire Pump', price:19.50, categories: ['Cycling'] })

        change the save logic to find and update:
            Product.findOneAndUpdate({ name: 'Tire Pump'}, {price: 100}, {new:true})
                .then(data => {
                    console.log("IT WORKED")
                    console.log(data);
                })
                .catch(err => {
                    console.log("OH NO ERROR!")
                    console.log(err);
                })
            // result:
            {
            qty: { online: 0, instore: 0 },
            onSale: false,
            categories: [ 'Cycling' ],
            _id: 60ad3a248653330d207b2b76,
            name: 'Tire Pump',
            price: 100,
            __v: 0
            }

        Run it again but with a negative number as the price:
            Product.findOneAndUpdate({ name: 'Tire Pump'}, {price: -19.99}, {new:true})
                results the same as above: thenumber validator did nothing

        run it like this for validators to work:
            Product.findOneAndUpdate({ name: 'Tire Pump'}, {price: 9.99}, {new:true, runValidators: true})
                result: we get the validation error that we are looking for
                    OH NO ERROR!
                            Error: Validation failed: price: Path `price` (-9.99) is less than minimum allowed value (0).
                                at ValidationError.inspect (C:\Users\gramk\OneDrive\Desktop\Colt-Bootcamp-2021\sec37\node_modules\mongoose\lib\error\validation.js:47:26)
                                    ..............................................
                            _message: 'Validation failed'
                            }
                            CONNECTION OPEN!!!

388. Mongoose Validation Errors

        Edit price Schema: + change price to a positive to pass prev validation constraints
             price: {
                        type: Number,
                        required: true,
                        min: [0, 'Price must be positive!'] // here the first is the default and the second is the message
                    },
                        run results in error : Price must be positive!

        add size schema:
                size: {
                        type: String,
                        enum: ['S', 'M', 'L']
                      }

        this time make new bike obj again :
            const bike = new Product({ name: 'Cycling Jersey', price:28.50, categories: ['Cycling'], size: 'XS' })
            bike.save()
                .then(data => {
                    console.log("IT WORKED")
                    console.log(data);
                })
                .catch(err => {
                    console.log("OH NO ERROR!")
                    console.log(err);
                })

        
